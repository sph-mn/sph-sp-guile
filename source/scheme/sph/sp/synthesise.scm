(library (sph sp synthesise)
  (export
    seq
    seq-block-series
    seq-event-data
    seq-event-data-end
    seq-event-data-f
    seq-event-data-start
    seq-event-group
    seq-event-list
    seq-event-new
    seq-event-state
    seq-event-state-update
    sp-band-event
    sp-band-partials
    sp-block
    sp-block-series
    sp-blocks->file
    sp-call-with-output-file
    sp-clip~
    sp-noise-exponential~
    sp-noise-normal~
    sp-noise-uniform~
    sp-path
    sp-phase
    sp-samples-list-add-offsets
    sp-sine~
    sp-square~
    sp-wave-event
    sph-sp-synthesis-description)
  (import
    (ice-9 futures)
    (rnrs exceptions)
    (sph)
    (sph list)
    (sph sp)
    (sph spline-path)
    (sph vector)
    (only (guile)
      compose
      const
      make-list
      modulo
      random:exp
      random:uniform
      random:normal
      *random-state*)
    (only (sph number) float-sum)
    (only (srfi srfi-1) zip))

  (define sph-sp-synthesis-description
    "wave and noise generators, sequencing, block generation.
     time is in number of samples")

  (define* (sp-noise-uniform~ #:optional (state *random-state*)) (- (* 2 (random:uniform state)) 1))
  (define* (sp-noise-exponential~ #:optional (state *random-state*)) (- (* 2 (random:exp state)) 1))
  (define* (sp-noise-normal~ #:optional (state *random-state*)) (- (* 2 (random:normal state)) 1))

  (define* (sp-square~ t #:optional (wavelength 96000))
    "integer integer -> sample
     center falls between two samples with even wavelengths"
    (if (< (modulo (* 2 t) (* 2 wavelength)) wavelength) -1 1))

  (define* (sp-sine~ t #:optional (wavelength 96000))
    "integer integer -> sample
     return a value for a repeating sine with a wavelength of width.
     if wavelength is divisible by four then maxima are sample aligned"
    (sin (* t (/ (* 2 sp-pi) wavelength))))

  (define (sp-clip~ a) "eventually adjust value to not exceed -1 or 1"
    (if (< 0 a) (min 1.0 a) (max -1.0 a)))

  (define (sp-phase y change phase-size)
    "number number number -> number
     phase generator that allows for high resolution modulation and non-linear transitions.
     * y: previous result or another starting value to continue from
     * change: how fast the phase should progress. frequency
     * phase-size: value at which the cycle should repeat
     example: (sp-phase 0.0 (/ (* 2 sp-pi) 200) (* 2 sp-pi))"
    (let (y (float-sum change y)) (if (< phase-size y) (float-sum y (- phase-size)) y)))

  (define* (sp-path a #:optional (dimension 1))
    "-> procedure:{t -> number/(number ...)}
     return a procedure that gives point values for time offset values.
     dimension selects a number from result points.
     dimension is ignored for procedures and numbers.
     input can be
     * procedure: will be used as is
     * number/(number): will be returned for any point on path
     * (list ...): a (sph spline-path) configuration"
    (cond
      ((procedure? a) a)
      ( (spline-path? a)
        (let (b (spline-path->procedure a)) (if dimension (l (t) (list-ref (b t) dimension)) b)))
      ((number? a) (const a))
      ( (list? a)
        (if (list? (first a)) (sp-path (spline-path-new a) dimension)
          (const (if dimension (list-ref a dimension) a))))
      (else (raise (q invalid-sp-path)))))

  (define (sp-block t size output f . state)
    "integer integer (samples:channel ...) f any ... -> output
     add to output size number of samples generated by f.
     samples are summed with existing samples"
    (first
      (apply sp-fold-integers size
        (l (sample-index . state)
          (apply f (+ t sample-index)
            (l (samples . state)
              (for-each
                (l (a b)
                  (sp-samples-set! a sample-index (float-sum (sp-samples-ref a sample-index) b)))
                output samples)
              state)
            state))
        state)))

  (define (sp-block-series count channels size f . state)
    "integer integer integer procedure:{integer integer block any ... -> } any ... -> (samples ...)"
    (apply sp-map-fold-integers count
      (l (t . state)
        (let (output (map-integers channels (l (a) (sp-samples-new size))))
          (list output (apply f (* t size) size output state))))
      state))

  (define*
    (sp-wave-event start end amplitudes wavelength #:key (phase 0) (generator sp-sine~)
      (phase-length 96000))
    "integer integer (partial-config ...) -> seq-event
     partial-config: ((amplitude ...) wavelength phase-offset)
     phase-offset: number
     amplitude, wavelength: sp-path"
    (seq-event-new start end
      (let
        ( (amplitudes (map sp-path amplitudes)) (wavelength (sp-path wavelength))
          (null-samples (make-list (length amplitudes) 0)))
        (l (t event)
          (let ((wavelength (wavelength t)) (phase (seq-event-state event)))
            (if (zero? wavelength) (pair null-samples event)
              (let*
                ( (phase (sp-phase phase (round (/ phase-length wavelength)) phase-length))
                  (sample (generator phase)))
                (pair (map (l (a) (* (a t) sample)) amplitudes)
                  (seq-event-state-update event phase)))))))
      phase))

  (define*
    (sp-band-event start end amplitudes cut-l cut-h #:key (noise sp-noise-uniform~)
      (trn-l (const 0.01))
      (trn-h (const 0.01)))
    (seq-event-new start end
      (let
        ( (amplitudes (map sp-path amplitudes)) (cut-l (sp-path cut-l)) (cut-h (sp-path cut-h))
          (trn-l (sp-path trn-l)) (trn-h (sp-path trn-h)))
        (l (t event)
          (apply
            (l (sample state)
              (let (sample (sp-samples-ref sample 0))
                (pair (map (l (a) (* (a t) sample)) amplitudes)
                  (seq-event-state-update event state))))
            (sp-windowed-sinc-bp-br (sp-samples-new 1 (noise)) (cut-l t)
              (cut-h t) (trn-l t) (trn-h t) #f (seq-event-state event)))))
      #f))

  (define (sp-call-with-output-file path channels sample-rate f)
    (let* ((file (sp-file-open path sp-file-mode-write channels sample-rate)) (result (f file)))
      (sp-file-close file) result))

  (define (sp-blocks->file a path channels sample-rate size)
    "((samples:channel ...):block ...) string integer integer integer -> unspecified"
    (if (not (null? a))
      (sp-call-with-output-file path channels
        sample-rate (l (file) (each (l (a) (sp-file-write file a size)) a)))))

  (define* (sp-samples-list-add-offsets b #:optional (start 0))
    "(samples ...) [integer] -> ((sample-offset samples) ...)
     map each samples vector in input to a pair with the cumulative sample
     offset of the length of sample vectors starting from start.
     for example a list with sample vector sizes 8 2 3 would create
     a list ((0 samples) (8 samples) (10 samples))"
    (let loop ((b b) (offset start))
      (if (null? b) b
        (pair (pair offset (first b)) (loop (tail b) (+ (sp-samples-length (first b)) offset))))))

  (define* (seq-event-new start end f #:optional state)
    "procedure integer [integer any] -> seq-event" (pair state (vector start end f)))

  (define (seq-event-list . a) "event ... -> list"
    (list-sort-with-accessor < (compose seq-event-data-start seq-event-data) a))

  (define (seq-event-group start end events)
    (seq-event-new start end
      (l (t event)
        (seq t (l (samples state) (pair samples (seq-event-state-update event state)))
          (seq-event-state event)))
      events))

  (define (seq-event-state-update a state) (pair state (tail a)))
  (define seq-event-data-start (vector-accessor 0))
  (define seq-event-data-end (vector-accessor 1))
  (define seq-event-data-f (vector-accessor 2))
  (define seq-event-data tail)
  (define seq-event-state first)

  (define (seq time c events)
    "integer seq-events procedure:{samples rest-events -> any} -> any
     calls one or multiple functions at predefined times and sums the resulting samples"
    (define (finish results rest c)
      (if (null? results) (c null rest)
        (c (map-apply float-sum (apply zip (map first results))) (append (map tail results) rest))))
    (let loop ((results null) (rest events))
      (if (null? rest) (finish results rest c)
        (let* ((a (first rest)) (b (seq-event-data a)) (start (seq-event-data-start b)))
          (if (< time start) (finish results rest c)
            (if (> time (seq-event-data-end b)) (loop results (tail rest))
              (loop (pair ((seq-event-data-f b) (- time start) a) results) (tail rest))))))))

  (define (seq-block-series events count channels size)
    (first
      (sp-block-series count channels
        size (l (t size output events) (sp-block t size output seq events)) events))))
