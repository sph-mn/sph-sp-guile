(library (sph sp synthesise)
  (export
    seq
    seq-event-end
    seq-event-end-set!
    seq-event-f
    seq-event-f-set!
    seq-event-new
    seq-event-start
    seq-event-start-set!
    seq-event-state
    seq-event-state-set!
    sp-band-event
    sp-band-partials
    sp-block
    sp-block-series
    sp-blocks->file
    sp-call-with-output-file
    sp-clip~
    sp-noise-exponential~
    sp-noise-normal~
    sp-noise-uniform~
    sp-path
    sp-phase
    sp-samples-list-add-offsets
    sp-sine~
    sp-square~
    sp-wave-event
    sph-sp-synthesis-description)
  (import
    (ice-9 futures)
    (rnrs exceptions)
    (sph)
    (sph list)
    (sph sp)
    (sph spline-path)
    (sph vector)
    (only (guile)
      const
      make-list
      modulo
      random:exp
      random:uniform
      random:normal
      *random-state*)
    (only (sph number) float-sum)
    (only (srfi srfi-1) zip))

  (define sph-sp-synthesis-description
    "wave and noise generators, sequencing, block generation.
     time is in number of samples")

  (define* (sp-noise-uniform~ #:optional (state *random-state*)) (- (* 2 (random:uniform state)) 1))
  (define* (sp-noise-exponential~ #:optional (state *random-state*)) (- (* 2 (random:exp state)) 1))
  (define* (sp-noise-normal~ #:optional (state *random-state*)) (- (* 2 (random:normal state)) 1))

  (define* (sp-square~ t #:optional (wavelength 96000))
    "integer integer -> sample
     center falls between two samples with even wavelengths"
    (if (< (modulo (* 2 t) (* 2 wavelength)) wavelength) -1 1))

  (define* (sp-sine~ t #:optional (wavelength 96000))
    "integer integer -> sample
     return a value for a repeating sine with a wavelength of width.
     if wavelength is divisible by four then maxima are sample aligned"
    (sin (* t (/ (* 2 sp-pi) wavelength))))

  (define (sp-clip~ a) "eventually adjust value to not exceed -1 or 1"
    (if (< 0 a) (min 1.0 a) (max -1.0 a)))

  (define (sp-phase y change phase-size)
    "number number number -> number
     phase generator that allows for high resolution modulation and non-linear transitions.
     * y: previous result or another starting value to continue from
     * change: how fast the phase should progress. frequency
     * phase-size: value at which the cycle should repeat
     example: (sp-phase 0.0 (/ (* 2 sp-pi) 200) (* 2 sp-pi))"
    (let (y (float-sum change y)) (if (< phase-size y) (float-sum y (- phase-size)) y)))

  (define* (sp-path a #:optional (dimension 1))
    "-> procedure:{t -> number/(number ...)}
     return a procedure that gives point values for time offset values.
     dimension selects a number from result points.
     dimension is ignored for procedures and numbers.
     input can be
     * procedure: will be used as is
     * number/(number): will be returned for any point on path
     * (list ...): a (sph spline-path) configuration"
    (cond
      ((procedure? a) a)
      ( (spline-path? a)
        (spline-path->procedure
          (if dimension
            (let (a (spline-path-copy a))
              (spline-path-output-mapper-set! a (l (a t) (list-ref a dimension))) a)
            a)))
      ((number? a) (const a))
      ( (list? a)
        (if (list? (first a))
          (spline-path->procedure
            (spline-path-new a #f (and dimension (l (a t) (list-ref a dimension)))))
          (const (if dimension (list-ref a dimension) a))))
      (else (raise (q invalid-sp-path)))))

  (define (sp-block t size output f . state)
    "integer integer (samples:channel ...) f any ... -> output
     add to output size number of samples generated by f.
     samples are summed with existing samples"
    (first
      (apply sp-fold-integers size
        (l (sample-index . state)
          (apply
            (l (samples . state)
              (for-each
                (l (a b)
                  (sp-samples-set! a sample-index (float-sum (sp-samples-ref a sample-index) b)))
                output samples)
              state)
            (apply f (+ t sample-index) state)))
        state)))

  (define (sp-block-series channels count size f . state)
    "integer integer integer procedure:{integer integer block any ... -> } any ... -> (samples ...)"
    (apply sp-map-fold-integers count
      (l (t . state)
        (let (output (map-integers channels (l (a) (sp-samples-new size))))
          (list output (apply f (* t size) size output state))))
      state))

  (define*
    (sp-wave-event start end amplitudes wavelength #:key (phase 0) (generator sp-sine~)
      (phase-length 96000))
    "integer integer (partial-config ...) -> seq-event
     partial-config: ((amplitude ...) wavelength phase-offset)
     phase-offset: number
     amplitude, wavelength: sp-path"
    (seq-event-new start end
      (let
        ( (amplitudes (map sp-path amplitudes)) (wavelength (sp-path wavelength))
          (null-samples (make-list (length amplitudes) 0)))
        (l (t event)
          (let ((wavelength (wavelength t)) (phase (seq-event-state event)))
            (if (zero? wavelength) null-samples
              (let*
                ( (phase (sp-phase phase (round (/ phase-length wavelength)) phase-length))
                  (sample (generator phase)))
                (seq-event-state-set! event phase) (map (l (a) (* (a t) sample)) amplitudes))))))
      phase))

  (define*
    (sp-band-event start end amplitudes cut-l cut-h #:key (noise sp-noise-uniform~)
      (trn-l (const 0.01))
      (trn-h (const 0.01)))
    (seq-event-new start end
      (let
        ( (amplitudes (map sp-path amplitudes)) (cut-l (sp-path cut-l)) (cut-h (sp-path cut-h))
          (trn-l (sp-path trn-l)) (trn-h (sp-path trn-h)))
        (l (t event)
          (apply
            (l (sample state)
              (let (sample (sp-samples-ref sample 0)) (seq-event-state-set! event state)
                (map (l (a) (* (a t) sample)) amplitudes)))
            (sp-windowed-sinc-bp-br (sp-samples-new 1 (noise)) (cut-l t)
              (cut-h t) (trn-l t) (trn-h t) #f (seq-event-state event)))))
      #f))

  (define* (seq-event-new start end f #:optional event-state)
    "procedure integer [integer any] -> vector" (vector start end f event-state))

  (define seq-event-start (vector-accessor 0))
  (define seq-event-end (vector-accessor 1))
  (define seq-event-f (vector-accessor 2))
  (define seq-event-state (vector-accessor 3))
  (define seq-event-start-set! (vector-setter 0))
  (define seq-event-end-set! (vector-setter 1))
  (define seq-event-f-set! (vector-setter 2))
  (define seq-event-state-set! (vector-setter 3))
  (define (seq-events-new a) "list -> list" (list-sort-with-accessor < seq-event-start a))

  (define (seq time events)
    "integer integer (samples:channel ...) (event ...) any -> (sample events)
     calls one or multiple functions at predefined times and sums the results"
    (define (join-samples samples)
      (if (null? samples) samples (map-apply float-sum (apply zip samples))))
    (let loop ((samples null) (result-events null) (events events))
      (if (null? events) (list (join-samples samples) result-events)
        (let* ((a (first events)) (start (seq-event-start a)))
          (if (< time start) (list (join-samples samples) (append result-events events))
            (if (> time (seq-event-end a)) (loop samples result-events (tail events))
              (loop (pair ((seq-event-f a) (- time start) a) samples) (pair a result-events)
                (tail events))))))))

  (define (sp-call-with-output-file path channels sample-rate f)
    (let* ((file (sp-file-open path sp-file-mode-write channels sample-rate)) (result (f file)))
      (sp-file-close file) result))

  (define (sp-blocks->file a path channels sample-rate size)
    "((samples:channel ...):block ...) string integer integer integer -> unspecified"
    (if (not (null? a))
      (sp-call-with-output-file path channels
        sample-rate (l (file) (each (l (a) (sp-file-write file a size)) a)))))

  (define* (sp-samples-list-add-offsets b #:optional (start 0))
    "(samples ...) [integer] -> ((sample-offset samples) ...)
     map each samples vector in input to a pair with the cumulative sample
     offset of the length of sample vectors starting from start.
     for example a list with sample vector sizes 8 2 3 would create
     a list ((0 samples) (8 samples) (10 samples))"
    (let loop ((b b) (offset start))
      (if (null? b) b
        (pair (pair offset (first b)) (loop (tail b) (+ (sp-samples-length (first b)) offset)))))))
